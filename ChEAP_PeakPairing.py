#!/usr/bin/env python
'''Perform ChIP-exo peak pairing'''

#import built-in modules
import os,sys
import re
import string
from optparse import OptionParser
import warnings
import string
import collections
import math
import sets
import numpy

#import third-party modules
from bx.bitset import *
from bx.bitset_builders import *
from bx.intervals import *
from bx.binned_array import BinnedArray
from bx_extras.fpconst import isNaN
from bx.bitset_utils import *
from bx.bbi.bigwig_file import BigWigFile

#built in modules
from qcmodule import fasta
from qcmodule import cigar
from qcmodule import BED
from qcmodule import motif
#changes to the paths


__author__ = "Liguo Wang"
__copyright__ = "Copyright 2012, Wei Li's Lab"
__credits__ = []
__license__ = "GPL"
__version__ = "2.0"
__maintainer__ = "Liguo Wang"
__email__ = "liguow@bcm.edu"
__status__ = "Development" #Prototype or Production

logo='''
   _____ _     ______          _____  
  / ____| |   |  ____|   /\   |  __ \ 
 | |    | |__ | |__     /  \  | |__) |
 | |    | '_ \|  __|   / /\ \ |  ___/ 
 | |____| | | | |____ / ____ \| |     
  \_____|_| |_|______/_/    \_\_|     
ChIP-Exo  Analysis  Pipeline (Peak Pairing)                                      
'''


def peak_interval(infile):
	'''build interval tree for forward peak and reverse peak'''
	range_FP={}	#range for forward peaks
	range_RP={}	#range for reverse peaks
	
	for line in open(infile,'r'):
		if line.startswith(("#","track","browser")):continue	#remove track information
		if not line.strip():continue	#remove blank line
		fields=line.rstrip('\n ').split()
		if len(fields) <6: continue
		
		chrom = fields[0]
		start = int(fields[1])
		end = int(fields[2])
		area = round(float(fields[3]))
		pvalue = round(float(fields[4]))
		strand = fields[5]
		height = round(float(fields[3]))
		
		if strand == '+':
			if chrom not in range_FP:
				range_FP[chrom] = IntervalTree()
			else:
				range_FP[chrom].insert_interval( Interval( start, end, value=[area,pvalue,height]) )
		elif strand == '-':
			if chrom not in range_RP:
				range_RP[chrom] = IntervalTree()
			else:
				range_RP[chrom].insert_interval( Interval( start, end, value=[area,pvalue,height]) )
		else:
			print >>sys.stderr, "unknown strand" + line,
			continue
	return (range_FP,range_RP)

def local_maximum_peak(lst,current_pos, distance_cutoff):
	'''pick out local maximum interval'''	#[Interval(119428445, 119428446, value=[3, 37.2617375672]), Interval(119428516, 119428517, value=[8, 84.8253807823])]
	
	mydict={}
	for intval in lst:
		#start_pos = intval.start
		end_pos = intval.end
		area = intval.value[0]			#use peak hight to measure peak quality
		pval = intval.value[1]			#use peak pvaliue to measure peak quality
		height = intval.value[2]
		mydict[end_pos] = pval
	for i in sorted(mydict, key=mydict.get,reverse=True):
		if i - current_pos < distance_cutoff:
			continue
		return(i, mydict[i])		#return coordinate and pvalue
	return (None,None)

def nearest_peak(lst,current_pos, distance_cutoff,forward_peak=True):
	'''find the nearest peak to current peak (should be larger than distance_cutoff.)'''
	mydict={}
	for intval in lst:
		#start_pos = intval.start
		end_pos = intval.end
		area = intval.value[0]			#use peak hight to measure peak quality
		pval = intval.value[1]			#use peak pvaliue to measure peak quality
		height = intval.value[2]
		mydict[end_pos] = pval
	if forward_peak:
		for i in sorted(mydict):
			if abs(i - current_pos) >= distance_cutoff:
				return(i, mydict[i])
				break
		return (None,None)
	else:
		for i in sorted(mydict,reverse=True):
			if abs(i - current_pos) >= distance_cutoff:
				return(i, mydict[i])
				break
		return (None,None)
	
	
def local_maximum_signal(bw_obj, current_pos, chrom, start, end, distance_cutoff):
	'''pick out local masimum signal'''
	mydict={}
	if start <0: start =0
	lst = bw_obj.get_as_array(chrom,start,end)
	
	nan_count=0
	for i,j in enumerate(lst):
		if numpy.isnan(j):
			mydict[start + i +1] = 0
			nan_count +=1
		else:
			mydict[start + i +1] = j
	if nan_count == len(lst):
		return (None,None)
	for i in sorted(mydict, key=mydict.get,reverse=True):
		if abs(i - current_pos) < distance_cutoff:
			continue
		return(i, mydict[i])		#return coordinate and height
	return (None,None)

	
			
def main():
	usage="%prog [options]"
	parser = OptionParser(usage,version="%prog " + __version__)
	parser.add_option("-i","--input-file",action="store",type="string",dest="input_file",help="File generated by ChEAP_PeakCalling.py")	
	parser.add_option("-b","--forward",action="store",type="string",dest="forward_bw",help="BigWig file for forward reads (extend 1 nt from 5' end of read)")
	parser.add_option("-d","--reverse",action="store",type="string",dest="reverse_bw",help="BigWig file for reverse reads (extend 1 nt from 5' end of read)")	
	parser.add_option("-o","--out-prefix",action="store",type="string",dest="output_prefix",help="Output peak-pair file in bed format")
	parser.add_option("-m","--max-dist",action="store",type="int",dest="max_distance",default=50,help="maximum distance allowed for peak pairing. default=%default")
	parser.add_option("-n","--min-dist",action="store",type="int",dest="min_distance",default=18,help="minimum distance allowed for peak pairing. default=%default")
	parser.add_option("-t","--mdpn",action="store",type="int",dest="max_ds_peak_num",default=1,help="maximum number of downstream peaks considered. set to 1 equivalent to picking teh nearest downstream peak. default=%default")	
	#parser.add_option("-s","--motif",action="store",type="string",dest="motif_file",help="motif file (.sites)")
	#parser.add_option("-p","--pvalue",action="store",type="float",dest="pvalue_cutoff",default=0.001,help="pvalue cutoff for motif. default=%default")
	#parser.add_option("-r","--genome",action="store",type="string",dest="reference_genome",help="reference genome in fasta format")

	(options,args)=parser.parse_args()

	if not (options.input_file and options.output_prefix and options.forward_bw and options.reverse_bw and options.output_prefix):
		parser.print_help()
		sys.exit(0)
	
	print >>sys.stderr, logo
	#pv_cutoff = -10*math.log10(options.pvalue_cutoff)
	fw_bw_obj = BigWigFile( file = open(options.forward_bw))
	rv_bw_obj = BigWigFile( file = open(options.reverse_bw))	
	PPO = open(options.output_prefix + "_PP.xls",'w')				#peak pairs: find reverse peak downstream of forward peak
	(fwd_peak,rev_peak) = peak_interval(options.input_file)
	PPS={}		#all peak pairs
	two_border_p = set()
	
	
	#==================================peak paring two border
	print >>sys.stderr, "Two-border peaks direct pairing ..."
	for line in open(options.input_file,'r'):
		if line.startswith(("#","track","browser")):continue	#remove track information
		if not line.strip():continue							#remove blank line
		fields=line.rstrip('\n ').split()
		if len(fields) <6: continue

		chrom = fields[0]
		strand = fields[5]
		if strand == '+':				#FP = Forward Peak
			FP_start = int(fields[1])								
			FP_end = int(fields[2])
			FP_area = round(float(fields[3]))
			FP_pvalue = round(float(fields[4]))
			#FP_height = round(float(fields[6]))
			
			ds_rv_peaks = rev_peak[chrom].downstream_of_interval(Interval(FP_start,FP_end,strand='+'),num_intervals = options.max_ds_peak_num, max_dist = options.max_distance)
			if len(ds_rv_peaks)>0:		#forward peak
				(RP_end, RP_pvalue) = nearest_peak(ds_rv_peaks, FP_end, options.min_distance)
				if RP_end is not None:					#found downstream peak
					PPS[chrom +":" + str(FP_end) + '+' + ';' + chrom + ':' + str(RP_end) + '-'] = [chrom, str(FP_end -1), str(RP_end), '2border:FP=' + str(FP_pvalue) + ':' + 'RP=' + str(RP_pvalue), '100', '+', str(FP_end -1),  str(RP_end),  '255,0,0',  '2',  '1,1',  '0,' + str(RP_end - FP_end)]
		if strand == '-':		#reverse peak
			RP_start = int(fields[1])
			RP_end = int(fields[2])
			RP_area = round(float(fields[3]))
			RP_pvalue = round(float(fields[4]))
			#RP_height = round(float(fields[6]))

			us_fw_peaks = fwd_peak[chrom].upstream_of_interval(Interval(RP_start,RP_end,strand='+'),num_intervals = options.max_ds_peak_num, max_dist = options.max_distance)			
			if len(us_fw_peaks) > 0:
				(FP_end, FP_pvalue) = nearest_peak(us_fw_peaks, RP_end, options.min_distance,forward_peak=False)
				if FP_end is not None:
					PPS[chrom +":" + str(FP_end) + '+' + ';' + chrom + ':' + str(RP_end) + '-'] = [chrom, str(FP_end -1), str(RP_end),'2border:FP=' + str(FP_pvalue) + ':' + 'RP=' + str(RP_pvalue), '100', '+', str(FP_end -1), str(RP_end), '255,0,0','2','1,1','0,' + str(RP_end - FP_end)]

	for key in PPS:
		for i in key.split(';'):
			two_border_p.add(i)
	
	
	#==================================peak paring single border
	print >>sys.stderr, "Single-border peaks extension ..."
	for line in open(options.input_file,'r'):
		if line.startswith(("#","track","browser")):continue	#remove track information
		if not line.strip():continue							#remove blank line
		fields=line.rstrip('\n ').split()
		if len(fields) <6: continue
		chrom = fields[0]
		end = int(fields[2])
		strand = fields[5]
		
		if (chrom + ':' + str(end) + strand) in two_border_p:			#peaks already paired, skip
			continue
		
		if strand == '+':
			FP_end = end
			FP_pvalue = round(float(fields[4]))
			(RP_end, RP_score) = local_maximum_signal(rv_bw_obj, FP_end, chrom, FP_end, FP_end + options.max_distance, options.min_distance)	
			if RP_end is not None:
				PPS[chrom +":" + str(FP_end) + '+' + ';' + chrom + ':' + str(RP_end) + '-'] = [chrom, str(FP_end -1), str(RP_end),'1border:FP=' + str(FP_pvalue) + ':' + 'RP=NA', '100', '+', str(FP_end -1), str(RP_end), '255,0,0','2','1,1','0,' + str(RP_end - FP_end)]				
		if strand == '-':
			RP_end = end
			RP_pvalue = round(float(fields[4]))
			(FP_end, FP_score) = local_maximum_signal(fw_bw_obj, RP_end, chrom, RP_end - options.max_distance, RP_end, options.min_distance)	
			if FP_end is not None:
				PPS[chrom +":" + str(FP_end) + '+' + ';' + chrom + ':' + str(RP_end) + '-'] = [chrom, str(FP_end -1), str(RP_end),'1border:FP=NA' + ':' + 'RP=' +  str(RP_pvalue), '100', '+', str(FP_end -1), str(RP_end), '255,0,0','2','1,1','0,' + str(RP_end - FP_end)]
	
	print >>sys.stderr, "Report peak pairs ..."
	for i in PPS:
		print >>PPO, '\t'.join(PPS[i])
	
if __name__=='__main__':
	main()

"""
	#===============motif
	AR_pval={
		67.0:	5.68434188608e-14,
		66.0:	7.92965693108e-12,
		65.0:	1.49583456732e-10,
		64.0:	1.38501832225e-09,
		63.0:	8.3332736267e-09,
		62.0:	3.76348481268e-08,
		61.0:	1.38830699825e-07,
		60.0:	4.41300912257e-07,
		59.0:	1.25254740624e-06,
		58.0:	3.25155856729e-06,
		57.0:	7.84689467537e-06,
		56.0:	1.78026948561e-05,
		55.0:	3.82773957455e-05,
		54.0:	7.8469600993e-05,
		53.0:	0.000154116966414,
		}
	Fox_pval={
		78.0:	0.0,
		77.0:	4.68958205602e-13,
		76.0:	5.81223957852e-12,
		75.0:	4.22204493589e-11,
		74.0:	2.26251017921e-10,
		73.0:	9.99619942377e-10,
		72.0:	3.80488529572e-09,
		71.0:	1.28728885329e-08,
		70.0:	3.9492604742e-08,
		69.0:	1.11464174779e-07,
		68.0:	2.92654050327e-07,
		67.0:	7.21070165355e-07,
		66.0:	1.67917647786e-06,
		65.0:	3.71768908281e-06,
		64.0:	7.86398676667e-06,
		63.0:	1.59597990006e-05,
		62.0:	3.11880190509e-05,
		61.0:	5.88657119351e-05,
		60.0:	0.000107598678511,
		}
	
	#===============================motif searching
	print >>sys.stderr, "Loading reference genome " + options.reference_genome + ' ...'
	ref_genome=fasta.Fasta(options.reference_genome)
	print >>sys.stderr, "Convert motif sites file into PWM (position weighted matrix)..."	
	score2pval={}
	pwm_dict=motif.sites2pwm(options.motif_file)
	for key in pwm_dict:
		print >>sys.stderr, "\nPWM for Motif: " + key
		print >>sys.stderr, pwm_dict[key]
	
	print >>sys.stderr, "\nCalculating motif match-score and probility ..."
	#for key in pwm_dict:
	#	score2pval[key] = motif.pwm_score2prob(pwm_dict[key],cutoff=options.pvalue_cutoff)
	score2pval['MA0007.1_AR']=AR_pval
	score2pval['Fox']=Fox_pval
	
	print >>sys.stderr, "Reading " + options.input_file
	print >>sys.stderr, "Searching motifs around peak roots ..."
	
	for line in open(options.input_file,'r'):
		if line.startswith(("#","track","browser")):continue	#remove track information
		if not line.strip():continue							#remove blank line
		fields=line.rstrip('\n ').split()
		if len(fields) <7: continue
		chrom = fields[0]
		start = int(fields[1])
		end = int(fields[2])
		
		try:
			for mot in pwm_dict:
				local_motif = ref_genome.search_motif(chr=chrom,st=end-100,end=end+100,pwm=pwm_dict[mot],score_cut=60,maximum=3)
				for i in local_motif:print i
		except:
			continue



#=
			#else:
			#	motif_ends=[]
			#	for mot in pwm_dict:
			#		best_motif = ref_genome.search_motif(chr=chrom, st=FP_end, end=FP_end + options.max_distance, pwm=pwm_dict[mot],maximum=1)
			#		
			#		motif_st = best_motif[1]
			#		motif_end = best_motif[2]
			#		motif_seq = best_motif[3]
			#		motif_score = best_motif[4]		
			#		motif_pvalue = score2pval[mot][motif_score]
			#		if motif_pvalue <= options.pvalue_cutoff:
			#			motif_ends.append(motif_end)
					

"""